<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Aiming Reticle (MediaPipe)</title>
    <style>
        body {
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background-color: #222; overflow: hidden;
        }
        #container {
            position: relative; width: 640px; height: 480px;
            border: 2px solid #555; background-color: #000; overflow: hidden;
        }
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1); /* Mirror mode */
            object-fit: cover;
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        /* Reticle Styles */
        .reticle { stroke: rgba(255, 0, 0, 0.8); stroke-width: 2; fill: none; }
        .reticle-center-dot { fill: rgba(255, 0, 0, 0.9); }
        .reticle-group { transition: transform 0.05s linear; }

        /* Loading/Error Messages */
         #message {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.1em; background-color: rgba(0, 0, 0, 0.75);
            padding: 15px; border-radius: 5px; z-index: 20; text-align: center;
            display: block; /* Initially visible */ max-width: 80%;
         }
         #message.error { background-color: rgba(200, 0, 0, 0.8); }
    </style>

    <!-- MediaPipe Face Detector and Camera Utils -->
    <script type="module">
        // Import necessary modules directly from CDN
        import { FaceDetector, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/face_detection.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js';
        // Drawing utils are optional, not used for the reticle here
        // import { drawRectangle } from 'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js';

        const videoElement = document.getElementById('webcam');
        const overlayElement = document.getElementById('overlay');
        const messageElement = document.getElementById('message');
        const containerElement = document.getElementById('container');
        let reticleGroup = null;
        let videoWidth = 640;
        let videoHeight = 480;

        // --- Message Handling ---
        function showMessage(msg, isError = false) {
            messageElement.innerHTML = msg;
            messageElement.className = isError ? 'error' : '';
            messageElement.style.display = 'block';
            if (isError) console.error(msg); else console.log(msg);
        }
        function hideMessage() {
            messageElement.style.display = 'none';
        }

        // --- Reticle Drawing ---
        function updateReticle(normalizedX, normalizedY, size = 40) {
            // Convert normalized coords (0.0-1.0) to pixel coords
            const pixelX = normalizedX * videoWidth;
            const pixelY = normalizedY * videoHeight;

            // Mirror the X coordinate for display on the flipped video
            const mirroredPixelX = videoWidth - pixelX;

            if (!reticleGroup) {
                // Create reticle elements if they don't exist
                reticleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                reticleGroup.classList.add('reticle-group');

                const halfSize = size / 2;
                const lineOffset = 5;
                const centerDotRadius = 3;

                // Define shapes relative to the center (0,0) of the group
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.classList.add('reticle');
                circle.setAttribute('r', halfSize);

                const lineH = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                lineH.classList.add('reticle');
                lineH.setAttribute('x1', -halfSize - lineOffset); lineH.setAttribute('y1', 0);
                lineH.setAttribute('x2', halfSize + lineOffset); lineH.setAttribute('y2', 0);

                const lineV = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                lineV.classList.add('reticle');
                lineV.setAttribute('x1', 0); lineV.setAttribute('y1', -halfSize - lineOffset);
                lineV.setAttribute('x2', 0); lineV.setAttribute('y2', halfSize + lineOffset);

                const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerDot.classList.add('reticle-center-dot');
                centerDot.setAttribute('r', centerDotRadius);

                reticleGroup.appendChild(circle);
                reticleGroup.appendChild(lineH);
                reticleGroup.appendChild(lineV);
                reticleGroup.appendChild(centerDot);
                overlayElement.appendChild(reticleGroup);
            }

            // Update the position using transform
            reticleGroup.setAttribute('transform', `translate(${mirroredPixelX}, ${pixelY})`);
            reticleGroup.style.display = ''; // Make sure it's visible
        }

        function hideReticle() {
            if (reticleGroup) {
                reticleGroup.style.display = 'none';
            }
        }

        // --- MediaPipe Face Detection ---
        function onResults(results) {
            // results object contains detections
            if (!results.detections || results.detections.length === 0) {
                 // console.log('No face detected');
                hideReticle();
                return;
            }

            // Assuming we use the first detected face
            const detection = results.detections[0];

            // The bounding box contains normalized coordinates
            const boundingBox = detection.boundingBox;
            if (!boundingBox) {
                hideReticle();
                return;
            }

            // Calculate normalized center of the bounding box
            const centerX = boundingBox.originX + boundingBox.width / 2;
            const centerY = boundingBox.originY + boundingBox.height / 2;

            // Update reticle position with normalized coordinates
            updateReticle(centerX, centerY);

            // Hide loading message once detection starts working
            if (messageElement.style.display !== 'none' && !messageElement.classList.contains('error')) {
                 setTimeout(hideMessage, 1000); // Hide after 1 second
            }
        }

        async function initializeMediaPipe() {
            showMessage('MediaPipe 리소스 로딩 중...');
            try {
                 // 1. Initialize FilesetResolver to locate WASM files
                 const filesetResolver = await FilesetResolver.forVisionTasks(
                     'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm' // Check for latest path if needed
                 );

                 // 2. Create FaceDetector instance
                 const faceDetector = new FaceDetector(filesetResolver, {
                    runningMode: 'VIDEO', // Process video stream
                    // model: 'short', // or 'full'; 'short' is faster for closer faces
                    // minDetectionConfidence: 0.5 // Adjust confidence threshold if needed
                 });

                await faceDetector.setOptions({ model: 'short', minDetectionConfidence: 0.5 });

                showMessage('MediaPipe 로드 완료. 카메라 준비 중...');

                // 3. Setup Camera Utils
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        // Called for each video frame
                        await faceDetector.detectForVideo(videoElement, performance.now(), onResults);
                    },
                    width: videoWidth,
                    height: videoHeight
                });

                // 4. Start the camera
                await camera.start();
                showMessage('카메라 시작됨. 얼굴을 보여주세요.');

            } catch (error) {
                 showMessage(`초기화 실패: ${error.message}`, true);
            }
        }


        // --- Run Initialization ---
        // Wait for the video element metadata to load to get dimensions
        videoElement.onloadedmetadata = () => {
            console.log('비디오 메타데이터 로드됨.');
            videoWidth = videoElement.videoWidth;
            videoHeight = videoElement.videoHeight;
            // Adjust container and SVG if needed based on actual video size
            containerElement.style.width = `${videoWidth}px`;
            containerElement.style.height = `${videoHeight}px`;
            overlayElement.setAttribute('viewBox', `0 0 ${videoWidth} ${videoHeight}`);
            console.log(`비디오 크기 설정: ${videoWidth}x${videoHeight}`);

            // Now initialize MediaPipe
            initializeMediaPipe();
        };

        // Handle potential video loading errors
         videoElement.onerror = (e) => {
             showMessage(`비디오 로드 오류: ${e.message || '알 수 없는 오류'}. 카메라 연결 및 권한을 확인하세요.`, true);
         };

    </script>

</head>
<body>
    <div id="container">
        <!-- Video element needs to be present before script runs -->
        <video id="webcam" autoplay muted playsinline></video>
        <svg id="overlay"></svg>
        <div id="message">페이지 로딩 중...</div>
    </div>
</body>
</html>
